package ir

import org.spoofax.interpreter.terms.IStrategoTerm._
import org.spoofax.interpreter.terms.{IStrategoAppl, IStrategoString, IStrategoTerm}

/**
  * Transforms the AST generated by the Spoofax parser into a Node of our intermediate
  * representation. This should be the first rewriter used in the rewrite phases.
  */
class SpoofaxToIrRewriter extends Rewriter[IStrategoTerm, Node] {

  private var unnamedVarId:Int = -1

  override def process(ast: IStrategoTerm): Node = {
    ast.getTermType match {
      case APPL => {
        ast.asInstanceOf[IStrategoAppl].getConstructor.getName match {
          case "BasicQuery" =>
            BasicQuery(
              process(ast.getSubterm(0)), // PathClause
              process(ast.getSubterm(1)), // ConstructClause
              process(ast.getSubterm(2))) // MatchClause
          case "Match" =>
            MatchClause(
              FullGraphPatternCondition(
                process(ast.getSubterm(0).getSubterm(0)), // FullGraphPattern
                process(ast.getSubterm(0).getSubterm(1))) // Where

                +: seqOfOptionals(ast.getSubterm(1))) // OPTIONAL
          case "Optional" =>
            FullGraphPatternCondition(
              process(ast.getSubterm(0).getSubterm(0)), // FullGraphPattern
              process(ast.getSubterm(0).getSubterm(1)), // Where
              isOptional = true)
          case "FullGraphPattern" =>
            FullGraphPattern(
              // ast.getSubterm(0) -> List of BasicGraphPatternLocation
              ast.getSubterm(0).getAllSubterms.map(subTerm => process(subTerm)))
          case "BasicGraphPatternLocation" =>
            BasicGraphPatternLocation(
              process(ast.getSubterm(0)), // BasicGraphPattern
              process(ast.getSubterm(1))) // Location
          case "BasicGraphPattern" =>
            new BasicGraphPattern(
              process(ast.getSubterm(0)), // VertexMatchPattern
              ast.getSubterm(1).getAllSubterms.map(subTerm => process(subTerm))) // EdgeVertexMatchPattern*
          case "Vertex" => {
            // If this is an unnamed variable, assign it a new name.
            var varDef: Node = process(ast.getSubterm(0)) // VarDef
            if (varDef == None())
              varDef = VarDef(Identifier(createVar("v")))
            VertexMatchPattern(
              varDef,
              process(ast.getSubterm(1))) // ObjectMatchPattern
          }
          case "VarDef" =>
            VarDef(Identifier(ast.getSubterm(0).asInstanceOf[IStrategoString].stringValue))
          case "ObjectMatchPattern" =>
            ObjectMatchPattern(
              process(ast.getSubterm(0)), // label predicates
              process(ast.getSubterm(1))) // property predicates
          case "ConjunctLabels" =>
            LabelPredicates(
              ast.getSubterm(0).getAllSubterms.map(subTerm => process(subTerm)))
          case "DisjunctLabels" =>
            DisjunctLabels(
              ast.getSubterm(0).getAllSubterms.map(subTerm =>
                Label(Identifier(subTerm.getSubterm(0).asInstanceOf[IStrategoString].stringValue))))
          case "Props" =>
            PropertyPredicates(
              ast.getSubterm(1).getAllSubterms.map(subTerm =>
                Property(
                  Identifier(subTerm.getSubterm(0).asInstanceOf[IStrategoString].stringValue),
                  // TODO: What is an Expression?
                  Expression())))
          case "EdgeVertexMatchPattern" => {
            EdgeVertexMatchPattern(
              connectionType(ast.getSubterm(0)),
              process(ast.getSubterm(0)), // connected entity match pattern
              process(ast.getSubterm(1))) // VertexMatchPattern
          }
          case "EdgeMatchPattern" => {
            // If this is an unnamed variable, assign it a new name.
            var varDef: Node = process(ast.getSubterm(0)) // VarDef
            if (varDef == None())
              varDef = VarDef(Identifier(createVar("e")))
            EdgeMatchPattern(
              varDef,
              process(ast.getSubterm(1)))
          }
          case "PathMatchPattern" => new PathMatchPattern
          // For OutEdge and InEdge we create a new edge variable by default.
          case "OutEdge" => createEdge // (a)->(b) <=> (a)-[e]->(b)
          case "OutConn" => createOrKeepEdge(ast)
          case "InEdge" => createEdge // (a)<-(b) <=> (a)<-[e]-(b)
          case "InConn" => createOrKeepEdge(ast)
          case "InOutEdge" =>
            if (ast.getSubtermCount == 0) createEdge else createOrKeepEdge(ast)
          case "UndirectedEdge" =>
            if (ast.getSubtermCount == 0) createEdge else createOrKeepEdge(ast)
          case "Location" => new Location
          case "Where" => new WhereClause
          case "Some" => process(ast.getSubterm(0))
          case "Edge" => process(ast.getSubterm(0)) // Edge->EdgeMatchPattern
          case "Path" => process(ast.getSubterm(0)) // Path->PathMatchPattern
          case _ => new None
        }
      }
      case _ => throw new IrException("process() cannot handle type " + ast.getTermType)
    }
  }

  private def seqOfOptionals(ast: IStrategoTerm): Seq[Node] = {
    ast.getTermType match {
      case APPL => {
        val termName: String = ast.asInstanceOf[IStrategoAppl].getConstructor.getName
        termName match {
          case "None" => List.empty
          case "Some" => seqOfOptionals(ast.getSubterm(0))
          case "OptionalClause" => {
            // ast.getSubterm(0) -> List of IStrategoTerm
            ast.getSubterm(0).getAllSubterms.map(optional => process(optional))
          }
          case _ => throw new IrException("seqOfOptionals() cannot handle term " + termName)
        }
      }
      case _ => throw new IrException("seqOfOptionals() cannot handle type " + ast.getTermType)
    }
  }

  private def connectionType(ast: IStrategoTerm): Node = {
    val termName: String = ast.asInstanceOf[IStrategoAppl].getConstructor.getName
    termName match {
      case "OutConn" => new OutConn
      case "OutEdge" => new OutConn
      case "InConn" => new InConn
      case "InEdge" => new InConn
      case "InOutEdge" => new InOutConn
      case "UndirectedEdge" => new UndirectedConn
      case _ => throw new IrException("connectionType() cannot handle term " + termName)
    }
  }

  private def createEdge: Node = {
    EdgeMatchPattern(
      VarDef(Identifier(createVar("e"))),
      ObjectMatchPattern(None(), None()))
  }

  private def createOrKeepEdge(ast: IStrategoTerm): Node = {
    // ast = OutConn, InConn, InOutEdge, UndirectedEdge
    val subTermName: String = ast.getSubterm(0).asInstanceOf[IStrategoAppl].getConstructor.getName
    subTermName match {
      case "None" => createEdge // (a)<-->(b) <=> (a)<-[e]->(b)
      case "Some" =>            // (a)<-[e?]->(b)
        process(ast.getSubterm(0))
    }
  }

  private def createVar(prefix: String): String = {
    unnamedVarId += 1
    prefix + "_" + unnamedVarId
  }
}
