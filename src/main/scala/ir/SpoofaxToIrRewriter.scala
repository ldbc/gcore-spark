package ir

import org.spoofax.interpreter.terms.IStrategoTerm._
import org.spoofax.interpreter.terms.{IStrategoAppl, IStrategoTerm}

/**
  * Transforms the AST generated by the Spoofax parser into a Node of our intermediate
  * representation. This should be the first rewriter used in the rewrite phases.
  */
class SpoofaxToIrRewriter extends Rewriter[IStrategoTerm, Node] {

  override def process(ast: IStrategoTerm): Node = {
    ast.getTermType match {
      case APPL => {
        ast.asInstanceOf[IStrategoAppl].getConstructor.getName match {
          case "BasicQuery" =>
            BasicQuery(
              process(ast.getSubterm(0)), // PathClause
              process(ast.getSubterm(1)), // ConstructClause
              process(ast.getSubterm(2))) // MatchClause
          case "Match" =>
            MatchClause(
              FullGraphPatternCondition(
                process(ast.getSubterm(0).getSubterm(0)), // FullGraphPattern
                process(ast.getSubterm(0).getSubterm(1))) // Where

                +: seqOfOptionals(ast.getSubterm(1))) // OPTIONAL
          case "Optional" =>
            FullGraphPatternCondition(
              process(ast.getSubterm(0).getSubterm(0)), // FullGraphPattern
              process(ast.getSubterm(0).getSubterm(1)), // Where
              isOptional = true)
          case "FullGraphPattern" =>
            FullGraphPattern(
              // ast.getSubterm(0) -> List of BasicGraphPatternLocation
              ast.getSubterm(0).getAllSubterms.map(subTerm => process(subTerm)))
          case "BasicGraphPatternLocation" =>
            BasicGraphPatternLocation(
              process(ast.getSubterm(0)), // BasicGraphPattern
              process(ast.getSubterm(1))) // Location
          case "BasicGraphPattern" => new BasicGraphPattern
          case "Location" => new Location
          case "Where" => new WhereClause
          case "Some" => process(ast.getSubterm(0))
          case _ => new None
        }
      }
      case _ => throw new IrException("process() cannot handle type " + ast.getTermType)
    }
  }

  private def seqOfOptionals(ast: IStrategoTerm): Seq[Node] = {
    ast.getTermType match {
      case APPL => {
        val termName: String = ast.asInstanceOf[IStrategoAppl].getConstructor.getName
        termName match {
          case "None" => List.empty
          case "Some" => seqOfOptionals(ast.getSubterm(0))
          case "OptionalClause" => {
            // ast.getSubterm(0) -> List of IStrategoTerm
            ast.getSubterm(0).getAllSubterms.map(optional => process(optional))
          }
          case _ => throw new IrException("seqOfOptionals() cannot handle term " + termName)
        }
      }
      case _ => throw new IrException("seqOfOptionals() cannot handle type " + ast.getTermType)
    }
  }
}
